## java并发库Lock公平锁和非公平锁
synchronized是java语言层面的，是内置的关键字  
synchronized同步的代码块可以有JVM自动释放  

ReentrantLock  
创建公平锁和非公平锁（默认）
可重入锁  
Lock则是JDK5中出现的一个包  
Lock需要程序员在finally块中手工释放  

一、公平锁/非公平锁
公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己  

非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式  

#### synchronized存在的问题
无法终端一个正在等候获得锁的线程，也无法通过投票得到锁，如果不相等下去，也就没法得到锁。

#### ReentrantLock类
java.util.concurrent.Lock中的Lock框架是锁定的一个抽象，它允许把锁定的实现作为java类，而不是作为语言的特性来实现。所以Lock可以有添加不同的功能。ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。    
**注意：**可以看到 Lock 和 synchronized 有一点明显的区别 —— lock 必须在 finally 块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放


### 处处都好？

看起来 ReentrantLock 无论在哪方面都比 synchronized 好 —— 所有 synchronized 能做的，它都能做，它拥有与 synchronized 相同的内存和并发性语义，还拥有 synchronized 所没有的特性，在负荷下还拥有更好的性能。那么，我们是不是应当忘记 synchronized ，不再把它当作已经已经得到优化的好主意呢？或者甚至用 ReentrantLock 重写我们现有的 synchronized 代码？实际上，几本 Java 编程方面介绍性的书籍在它们多线程的章节中就采用了这种方法，完全用 Lock 来做示例，只把 synchronized 当作历史。但我觉得这是把好事做得太过了。

### 还不要抛弃 synchronized

虽然 ReentrantLock 是个非常动人的实现，相对 synchronized 来说，它有一些重要的优势，但是我认为急于把 synchronized 视若敝屣，绝对是个严重的错误。 java.util.concurrent.lock 中的锁定类是用于高级用户和高级情况的工具 。一般来说，除非您对 Lock 的某个高级特性有明确的需要，或者有明确的证据（而不是仅仅是怀疑）表明在特定情况下，同步已经成为可伸缩性的瓶颈，否则还是应当继续使用 synchronized。

为什么我在一个显然“更好的”实现的使用上主张保守呢？因为对于 java.util.concurrent.lock 中的锁定类来说，synchronized 仍然有一些优势。比如，在使用 synchronized 的时候，不能忘记释放锁；在退出 synchronized 块时，JVM 会为您做这件事。您很容易忘记用 finally 块释放锁，这对程序非常有害。您的程序能够通过测试，但会在实际工作中出现死锁，那时会很难指出原因（这也是为什么根本不让初级开发人员使用 Lock 的一个好理由。）

另一个原因是因为，当 JVM 用 synchronized 管理锁定请求和释放时，JVM 在生成线程转储时能够包括锁定信息。这些对调试非常有价值，因为它们能标识死锁或者其他异常行为的来源。 Lock 类只是普通的类，JVM 不知道具体哪个线程拥有 Lock 对象。而且，几乎每个开发人员都熟悉 synchronized，它可以在 JVM 的所有版本中工作。在 JDK 5.0 成为标准（从现在开始可能需要两年）之前，使用 Lock 类将意味着要利用的特性不是每个 JVM 都有的，而且不是每个开发人员都熟悉的。

### 什么时候选择用 ReentrantLock 代替 synchronized

既然如此，我们什么时候才应该使用 ReentrantLock 呢？答案非常简单 —— 在确实需要一些 synchronized 所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。 ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数 synchronized 块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用 synchronized 开发，直到确实证明 synchronized 不合适，而不要仅仅是假设如果使用 ReentrantLock “性能会更好”。请记住，这些是供高级用户使用的高级工具。（而且，真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。）。一如既往，首先要把事情做好，然后再考虑是不是有必要做得更快。

> 参考：[java并发库Lock公平锁和非公平锁](https://www.cnblogs.com/xingzc/p/5750152.html)


# Java虚拟机
* 一、运行时数据区域（JVM内存模型）
    - 程序计数器
    - Java虚拟机栈
    - 本地方法栈
    - 堆
    - 方法区
    - 运行时常量池
    - 直接内存
* 垃圾收集
    - 判断一个对象是否可以被回收
    - 引用类型
    - 垃圾收集算法
    - 垃圾收集器
* 内存分配策略与回收策略
    - Minor GC和Full GC
    - 内存分配策略
    - Full GC的触发条件
* 类加载机制
    - 类的生命周期
    - 类加载过程
    - 类初始化时机
    - 类与类加载器
    - 双亲委派模型
    - 自定义类加载器

### 程序计数器
记录正在执行的虚拟机字节码指令的地址。
### Java虚拟机栈
每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息，从调用直到执行完的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程。  
该区域可能跑出的异常：  

* 线程请求的栈深度查过最大值，会抛出StackOverflowException
* 栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryException  
配置：java -Xss=

### 本地方法栈
本地方法一般是由C/C++或汇编语言编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
本地方法栈与java虚拟机栈类似，他们之间的区别只不过是本地方法栈为本地方法服务。

### 堆
几乎所有对象都在这里分配内存，是垃圾收集的主要区域（GC堆）  
现在的垃圾收集器基本采用都是分代收集算法，针对不同类型的对象采取不同的垃圾搜集策略，可以将堆区分为两大类：

* 新生代（Young Generation）
* 老年代（Old Generation）

新生代可以继续划分为三个空间：

* Eden（伊甸园）
* From Survivor（幸存者）
* To Survivor

堆不需要连续内存，并且可以动态增加其内存，增加失败会OutOfMemoryException

配置：java -Xms=  -Xmx=

### 方法区
存放已被加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。

### 运行时常量池
运行时常量池是方法区的一部分。
Class文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放到这个区域  
除了在编译器生成，还可以允许动态生成，例如String类的intern()方法  

### 直接内存
在JDK1.4中新加入了NIO类，它可以使用Native函数库直接分配堆外存，然后通过一个存储在Java堆里的DirectByteBuffer独享作为这块内存的引用进行操作。    
jdk1.4中新加入的NIO类，可以使用native方法直接分配堆外存，在使用时，避免了java堆和native堆来回复制数据，显著提性能。

## 二、垃圾收集
垃圾收集主要针对堆区和方法区进行。  
程序计数器、虚拟机栈、本地方法栈这三个区域属于线程私有，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。  

### 判断一个对象是否可被回收
**1.引用计数算法**
很高效，实现也简单。但是不能解决循环引用的问题  
**2.可达性分析算法**
可当作Java中GC Roots根节点的一般包括：
* 虚拟机栈中引用的对象
* 本地方法栈中引用的对象
* 方法区中类静态属性应用的对象
* 方法区中的常量应用的对象   

**3.方法区的回收**
方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收的性价比不高。主要是堆常量池的回收和对类的卸载。  

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，保证不会出现内存溢出。  

类的卸载条件很多，需要满足一下三个条件，并且满足了也不一定被卸载：

* 该类的所有实例都已回收，也就是堆中不存在该类的任何实例
* 该类的ClassLoader已被回收
* 该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问改类方法。

### 引用类型
判断引用类型与可达性分析算法有关，所以需要了解，java具有四种强度不同的引用类型。

**1.强引用**
被强引用关联的对象不会被回收  

**2.软引用**
被软引用关联的对象只有在内存不够的情况下才会被回收。  

**3.弱引用**
被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。  

**4.虚引用**

### 垃圾收集算法
**1.标记 - 清除**
![标记清除算法](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg)
标记存活的对象，然后清理掉未被标记的对象。
不足：

* 标记和清除过程效率都不高。
* 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

**2.标记 - 整理**
！[标记整理算法](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg)
让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。  

**3.复制**  
将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

**4.分代收集**
现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

* 新生代使用：复制算法
* 老年代使用：标记 - 清除 或者 标记 - 整理 算法

### 垃圾收集器
![七种垃圾收集器](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg)


以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
* 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

**1.Serial收集器**
Client模式下的默认新生代收集器，Serial收集器收集几十兆甚至一两百兆的新生代会停顿100多毫秒，简单高效，这点停顿可以接受。

**2.ParNew收集器**
它是Serial收集器的多线程版本。是Server模式下的首选新生代收集器，只有它能与CMS收集器配合工作。默认开启的线程数与CPU数量相同，可以使用-XX:ParallelGCThreads参数来设置线程数。

**3.Parallel Scavenge收集器**

**4.Serial Old收集器**

**5.Parallel Old收集器**

**6.CMS收集器**
CMS(Concurrent Mark Sweep)，Mark Sweep指的是标记 - 清除算法。  
分为以下四个流程：

* 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
* 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
* 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
* 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

* 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
* 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
* 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

**7.G1收集器**
G1(Garbage-First)，他是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予他的始名是未来可以替换掉CMS收集器。  

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。  

## 三、内存分配与回收策略
##Minor GC和Full GC##

* Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。
* Full GC：发生在老年代上，老年代对象其存活时间长，因此Full GC很少执行，执行速度比Minor GC慢很多

内存分配策略：
##1.对象有现在Eden分配##
大多数情况下，对象在新生代Eden区分配，当Eden区空间不够，发起Minor GC
##2.大对象直接进入老年代##
大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

##3.长期存活的对对象进入老年代##
为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。  

##4.动态对象年龄判定##
虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

##5.空间分配担保##
在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

### Full GC的触发条件
对于Minor GC，其出发条件非常简单，当Eden空间满时，就将出发一次Minor GC，而Full GC出发条件相对复杂：
##1.调用System.gc()## 
只是建议虚拟机执行Full GC,但是虚拟机不一定真正执行。不建议这样使用。  

##2.老年代空间不足##

##3.空间分配担保失败##

##4.JDK 1.7及以前的永久代空间不足##

##5.Concurent Mode Failure##

## 类的生命周期
![类的生命周期](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/32b8374a-e822-4720-af0b-c0f485095ea2.jpg)


包括以下7个阶段：

* 加载（Loading）
* 验证（Verification）
* 准备（Preparation）
* 解析（Resolution）
* 初始化（Initialization）
* 使用（Using）
* 卸载（Unloading）

### 类加载过程
包含了加载、验证、准备、解析和初始化这5各阶段。

#### 1.加载

加载是类加载的一个阶段，注意不要混淆。

加载过程完成以下三件事：

* 通过一个类的全限定名来获取定义此类的二进制字节流。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。
* 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

* 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
* 从网络中获取，最典型的应用是 Applet。
* 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
* 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

####2. 验证
确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机滋生的安全

#### 3.准备
类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。

实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。

注意，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```java
public static int value = 123;
```
如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。
```java
public static final int value = 123;
```

#### 4.解析
将常量池的符号引用替换为直接引用的过程。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持java的动态绑定

#### 5.初始化
初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 <clinit>() 方法的过程。

在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

## 类初始化时机
**1.主动引用**  
比你及规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列物种情况必须对类进行初始化（加载、验证、准备都会随之执行）：

* 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则必须先出发其初始化。
* 使用java.lang.reflet包的方法对垒进行反射调用的时候，如果类没有进行初始化，则需要先出发其初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类；
* 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke。methodHandle实例最后的解析结果为REF-getStatc, REF_putStatic, REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；
**2.被动引用**  
以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

通过子类引用父类的静态字段，不会导致子类初始化。
```java
System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义
```
通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
```java
SuperClass[] sca = new SuperClass[10];
```
常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
```java
System.out.println(ConstClass.HELLOWORLD);
```


