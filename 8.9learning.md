## 多个线程访问共享对象和数据的方式
+ 如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如买票系统可以这么做。
+ 掌握生产者消费者

## 为什么在Java中需要内部类？
* 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整
* 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏
* 方便编写事件驱动程序
* 方便编写线程代码

## 匿名内部类引用外部对象要加final修饰符的原因
为什么在匿名内部类中引用外部对象要加final修饰符呢，因为，在匿名内部类中引用的外部对象受到外部线程的作用域的制约有其特定的生命周期，以线程为例，当外部的变量生命周期已经完结之后，内部的线程还在运行，怎么样解决这个外部生命周期已经结束而在内部却需要继续使用呢，这个时候就需要在外部变量中添加final修饰符，其实内部匿名类使用的这个变量就是外部变量的一个“复制品”，即使外部变量生命周期已经结束，内部的“复制品“依然可用。  

> 一句话总结：生命周期不同所以需要一份“复制品” 

参考如下代码：
```java
        final Person p = new Person("Huangxin",20);
        System.err.println("执行线程前："+p);
        new Thread(new Runnable() {
            
            @Override
            public void run() {
                p.setName("Huangling");
                System.out.println("线程执行："+p);
            }
        }).start();
        System.err.println("执行线程后："+p);

//运行结果：  
//执行线程前：Person [name=Huangxin, age=20]
//执行线程后：Person [name=Huangxin, age=20]
//线程执行：Person [name=Huangling, age=20]
```

> 参考：[匿名内部类引用外部对象要加final修饰符的原因](https://blog.csdn.net/lb_383691051/article/details/47700693) 

## 线程池
线程池的概念与Executors类的应用   
    * 创建固定大小的线程池  
    * 创建单一缓存线程池  
    * 创建单一线程池（如何实现线程死掉后重新启动？）可以使用单一线程池  

## java5中的CyclicBarrier
犹如屏障，等待都到齐了再出发
## java5中的CountDownLatch
计时器，等归0后开始运作

## 多线程死锁的产生以及如何避免死锁
一、定义  
*死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。*
  
二、死锁产生的原因  
1）**系统资源的竞争**  
2）**进程推进顺序非法**  
3）**死锁产生的必要条件**  

+ **互斥条件**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。  
+ **不剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。  
+ **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。  
+ **循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有，如图2-15所示。
