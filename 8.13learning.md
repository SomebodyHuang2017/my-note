# MySQL索引
### 索引原理
本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

### 磁盘IO与预读取
考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。   

### 索引的数据结构
B+树，每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

#### b+树的查找过程
如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。  
#### b+树性质
* 索引字段要尽量的小** 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。  
* **索引的最左匹配特性** 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

### MySQL索引管理
**索引分类**  
一、功能  
1.索引的功能就是加速查找  
2.mysql中的primary key，unique联合唯一也都是索引，这些索引除了加速查询外还有约束功能  
二、MySQL的索引分类  
1.普通索引index: 加速查找  
2.唯一索引
    主键索引：primary key 加速查找+约束（不为空且唯一）
    唯一索引：unique 加速查找+约束（唯一）  
3.联合索引      
+ primary key(id,name):联合主键索引  
+ unique(id,name):联合唯一索引      
+ index(id,name):联合普通索引    
4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。  
5.空间索引spatial :了解就好，几乎不用

三、索引的两大类型hash与btree
```
#我们可以在创建上述索引的时候，为其指定索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

#不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
```

四、创建删除索引的语法
```
#方法一：创建表时
    　　CREATE TABLE 表名 (
                字段名1  数据类型 [完整性约束条件…],
                字段名2  数据类型 [完整性约束条件…],
                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                );


#方法二：CREATE在已存在的表上创建索引
        CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                     ON 表名 (字段名[(长度)]  [ASC |DESC]) ;


#方法三：ALTER TABLE在已存在的表上创建索引
        ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                             索引名 (字段名[(长度)]  [ASC |DESC]) ;
                             
#删除索引：DROP INDEX 索引名 ON 表名字;

创建/删除索引的语法
```

## 四种mysql存储引擎

* MyISAM
* Memory
* InnoDB
* Archive

## mysql存储引擎中InnoDB与MyISAM的区别以及应用场景
### 区别
* 事务处理
    - MyISAM非事务安全型
    - InnoDB是事务安全型
* 锁机制不同
    - MyISAM是表级锁
    - InnoDB是行级锁
* select、update、insert、delete操作
    - MyISAM如果执行大量的select，是个好选择
    - InnoDB如果执行大量的insert或update，出于性能方面的考虑，应该使用InnoDB
* 查询表的行数机制不同
    - MyISAM可以直接读取出保存好的行数，例如count(*)
    - InnoDB对于上述操作需要扫描遍历整个表计算行数
* 外键支持
    - MYISAM不支持外键，InnoDB支持外键

### 为什么MyISAM会比InnoDB的查询速度快
InnoDB在做select的时候，要维护的东西比MyISAM引擎要多很多  
1）数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少  
2）innodb寻址要映射到块，再到行，MYISAM 记录的直接是文件的OFFSET，定位比INNODB要快  
3）INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护  
    MVCC(Multi-Version Concurrency Control)多版本并发控制

### 应用场景
MyISAM适合：（1）做很多count的计算；（2）插入不频繁，查询非常频繁；（3）没有事务；  
InnoDB适合：（1）可靠性要求比较高，或者要求事务；（2）更新和查询都相当的频繁，并且行锁定的机比较大的情况。


## 协程
协程，又称微线程，纤程。英文名Coroutine。  
协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。  
子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。  
所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。  
子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。  
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。  
看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势?  
最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。   
第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。  
因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  


## CAS原理
CAS:Compare and Swap，翻译成比较并交换  
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。  
CAS通过调用JNI的代码实现的。compareAndSet()方法存在于Unsafe类中，而这个类存在于sun.misc包下面。这个方法调用的是C或C++方法  
关于CPU的锁有如下3种：  

* 处理器自动保证基本内存操作的原子性
* 使用总线锁保证原子性
* 使用缓存锁保证原子性

CAS缺点：

* 存在ABA问题，解决思路是使用版本号，java中提供一个类AtomicStampedReference来解决ABA问题  
* 自旋时间（循环时间长开销大）
* 只能保证一个共享变量的原子操作

AQS，非阻塞和原子变量类（java.util.concurrent.atomic包中的类）
![concurrent包的实现](http://dl.iteye.com/upload/attachment/0083/2584/b7b2472f-6b93-3f85-9e44-29a9ff774c8e.png)