## ConcurrentHashMap源码分析
在多线程的情况下，HashMap在1.7之前可能会产生链表成环，导致死循环，而在1.8虽然通过双链表的方式解决了这个bug，但是也会产生数据丢失的现象，所以HashMap是不安全的。而Hashtable虽然是线程安全的，但是它的锁成本太高，用的是synchronied对象锁，锁住整个表结构，在put操作和get等操作都需要加锁，效率底下。而java.util.concurrent包下面的ConcurrentHashMap则解决了上面出现的问题，因此多线程情况下，请使用ConcurrentHashMap。

知道了Hashtable性能差的原因，所以可以在此基础上进行改进，如果由多把锁，那么多线程访问效率自然就提升上去了。这就是ConcurrentHashMap所采用的 **“分段锁”**

ConcurrentHashMap采用了精妙的“分段锁”策略，它的主干是Segment数组。

Segment继承了ReentrantLock，所以它是一种可重入锁。一个Segment就是一个子哈希表，Segment中维护了一个HashEntry数组。 **所以，对于同一个Segment的操作才需要考虑线程同步，不同的Segment则不需要考虑**

结构：*ConcurrentHashMap* ---维护---> *Segment[]* ---维护---> *HashEntry[]*

HashEntry结构：
```java
 static final class HashEntry<K,V> {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry<K,V> next;
        //其他省略
} 
```

Segment类似于HashMap，一个Segment维护一个HashEntry数组：
```java
transient volatile HashEntry<K,V>[] table;
```
Segment构造方法：
```java
Segment(float lf, int threshold, HashEntry<K,V>[] tab) {
            this.loadFactor = lf;//负载因子
            this.threshold = threshold;//阈值
            this.table = tab;//主干数组即HashEntry数组
        }
```

ConcurrentHashMap中除了Segment数组还多出了几个变量，如SegmentShit,SegmentMask  
其中2的sshit次方等于ssize，例如ssize=16那么sshit=4；ssize=32那么sshift=5


### 如何定位Segment?
通过hash()方法重新散列key，保证散列均匀。然后将hash值与segmentShit无符号右移再与segmentMask进行与运算，定位segment
```java
 public V put(K key, V value) {
        Segment<K,V> s;
        //concurrentHashMap不允许key/value为空
        if (value == null)
            throw new NullPointerException();
        //hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀
        int hash = hash(key);
        //返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment
        int j = (hash >>> segmentShift) & segmentMask;
        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }
```
### 关于segmentShift和segmentMask
segmentShift和segmentMask这两个全局变量的主要作用是用来定位Segment，int j =(hash >>> segmentShift) & segmentMask。

**segmentMask**：段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性

**segmentShift**：2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，无符号右移segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。


**get方法无需加锁，由于其中涉及到的变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。**





