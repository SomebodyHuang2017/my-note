## ConcurrentHashMap源码分析
在多线程的情况下，HashMap在1.7之前可能会产生链表成环，导致死循环，而在1.8虽然通过双链表的方式解决了这个bug，但是也会产生数据丢失的现象，所以HashMap是不安全的。而Hashtable虽然是线程安全的，但是它的锁成本太高，用的是synchronied对象锁，锁住整个表结构，在put操作和get等操作都需要加锁，效率底下。而java.util.concurrent包下面的ConcurrentHashMap则解决了上面出现的问题，因此多线程情况下，请使用ConcurrentHashMap。

知道了Hashtable性能差的原因，所以可以在此基础上进行改进，如果由多把锁，那么多线程访问效率自然就提升上去了。这就是ConcurrentHashMap所采用的 **“分段锁”**

ConcurrentHashMap采用了精妙的“分段锁”策略，它的主干是Segment数组。

Segment继承了ReentrantLock，所以它是一种可重入锁。一个Segment就是一个子哈希表，Segment中维护了一个HashEntry数组。 **所以，对于同一个Segment的操作才需要考虑线程同步，不同的Segment则不需要考虑**

结构：*ConcurrentHashMap* ---维护---> *Segment[]* ---维护---> *HashEntry[]*

HashEntry结构：
```java
 static final class HashEntry<K,V> {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry<K,V> next;
        //其他省略
} 
```

Segment类似于HashMap，一个Segment维护一个HashEntry数组：
```java
transient volatile HashEntry<K,V>[] table;
```
Segment构造方法：
```java
Segment(float lf, int threshold, HashEntry<K,V>[] tab) {
            this.loadFactor = lf;//负载因子
            this.threshold = threshold;//阈值
            this.table = tab;//主干数组即HashEntry数组
        }
```

ConcurrentHashMap中除了Segment数组还多出了几个变量，如SegmentShit,SegmentMask  
其中2的sshit次方等于ssize，例如ssize=16那么sshit=4；ssize=32那么sshift=5


### 如何定位Segment?
通过hash()方法重新散列key，保证散列均匀。然后将hash值与segmentShit无符号右移再与segmentMask进行与运算，定位segment
```java
 public V put(K key, V value) {
        Segment<K,V> s;
        //concurrentHashMap不允许key/value为空
        if (value == null)
            throw new NullPointerException();
        //hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀
        int hash = hash(key);
        //返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment
        int j = (hash >>> segmentShift) & segmentMask;
        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }
```
### 关于segmentShift和segmentMask
segmentShift和segmentMask这两个全局变量的主要作用是用来定位Segment，int j =(hash >>> segmentShift) & segmentMask。

**segmentMask**：段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性

**segmentShift**：2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，无符号右移segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。


**get方法无需加锁，由于其中涉及到的变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。**

## 几个有意思的名词
* **僵尸进程**
    - 一个进程使用fork创建子进程，如果子进程推出，而父进程并没有跳出wait或waitpid获取子进程的状态信息，那么子进程的进程描述任然保存在系统中。这种进程称之为僵尸进程
* **孤儿进程**
    - 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，由init进程对它们万册灰姑娘状态收集工作。
* **缓存击穿**
    - 黑客故意区去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而导致数据库连接异常。
    - 解决方案：
        + 利用互斥锁，缓存失效，先去获得锁，得到锁之后，再去请求数据库。没得到锁，则休眠一段时间重试
        + 采用一部更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，一部起一个线程去读数据库，更新缓存。需要做缓存预热（项目启动前，先加载缓存）操作。
        + 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否有效合法如果不合法，则直接返回
* **缓存雪崩**
    - 缓存同一时间大面积失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据连接异常。
    - 解决方案:
        + 给缓存的失效时间加上随机值，避免集体失效。
        + 使用互斥锁，但是该方案吞吐量明显下降了。
        + 双缓存。我们由两个缓存，缓存A和缓存B，缓存A的失效时间为20分钟，缓存B不设置失效时间。然后做缓存预热操作。



