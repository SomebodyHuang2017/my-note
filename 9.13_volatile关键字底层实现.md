## volatile关键字的底层实现
通过利用工具获得class文件的汇编代码，会发现，标有volatil关键字的变量在写操作时，会在前面加上lock指令前缀。

而lock指令前缀会做两件事情：

* 将当前缓存行的数据写回到内存。lock指令前缀再执行指令的期间，会产生一个lock信号，lock信号会保证在该信号期间会独占任何共享内存。lock信号一般不锁总线锁，而是锁缓存锁。因为总线锁的开销非常大。
* 将缓存行的数据写回到内存的操作会使得其他CPU缓存了该地址的数据无效

### synchronized关键字的底层实现
synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取而代之的时ACC_SYNCHORNIZED表示，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHORNIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。

### Java虚拟机对synchronized的优化
所得状态有四种：

#### 偏向锁
偏向锁时java 6之后加入的新锁，是一种优化手段。经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，英雌为了减少同一线程获取锁的代价引入了偏向锁。
#### 轻量级锁
偏向锁失败，虚拟机并不会立即升级为重量级锁，他还会尝试使用一中称为轻量级锁的优化手段，此时Mark Word的结构也会变为轻量级锁的结构。轻量级锁的依据是：“对绝大部分的锁，在整个同步周期内都不存在竞争”。轻量级锁适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
#### 自旋锁
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。
#### 锁销除
消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。