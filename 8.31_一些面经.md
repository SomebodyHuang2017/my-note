### 1、自我介绍
各位面试官好！我叫黄鑫，就读于江西农业大学软件学院，目前是一名大四学生。首先非常感谢贵公司给我的这次面试机会，我此次应聘的职位是java开发工程师，我热爱编程，也非常喜欢计算机软件开发这类职业。在平时主要使用java语言，开发过一些上线项目，拥有一定的实践经验。平时主要通过自学来提升自己专业水平。。。

座右铭：力求用所学的知识将一件事情做到更好。细节

加入公司的规划：首先熟悉公司的技术栈，再次熟悉工作这一块的业务。

你有什么问题要问的：
1、可以提前入职，如果公司对这个有要求，那么我比较适合。
2、入职之后有没有什么培训？更好的熟悉技术栈，了解业务
3、部门团队有多少人，主要负责哪一方面？
4、您觉得，这份工作所需的能力，我还有哪些不具备？
5、我们还能见面吗？: )


### 2、你说你熟悉Java，那你说一下Java的特性以及面向对象的特点


### 3、知道那些设计模式？说一下单例模式，写一个能表现出你水平的一种写法
* 单例
* 装饰器
* 代理模式
* 工厂模式
* 模板方法
* 迭代器模式
* 原型模式

```java
public final class Singleton {
    private volatile static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if(instance == null){
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
            return instance;
        }
    }
}
```

###  4、tcp三次握手，为什么是三次，两次行不行
先讲一下三次握手的过程：
第一次握手是客户端发送一个同步包给服务器端设置头部字段SYN=1，seq=x，表示我要向你请求连接；当服务器接收到报文之后会给服务端返回一个报文端，seq=x+1 & ACK = 1，这是第二次握手，表示确认，回应客户端，这是第二次握手；客户端收到服务端的回应之后，又需要发送一个回复包给服务端，服务端接受报文，那么本次连接完成，客户端和服务端之间可以进行数据传输了。

再来说一下，为什么是三次，两次不行。如果第一次客户端发送的请求因为传输链路堵塞，在链路中等待了很久，客户端发现没有响应，于是认为请求遗失了，再向服务端发送一次，并且该次连接和服务端进行了通信，然后释放连接。这时，第一次发送的同步包过了很久终于到了服务端，如果是两次握手，那么这次服务端就会为客户端创建连接资源，因为是链路不稳定的原因，这一次连接是浪费的。如果大量出现这种情况那么服务端将会浪费大量资源。还有一种情况是服务端接受到客户端请求并了相应的报文，但是报文丢包了。没有传给客户端，客户端会以为请求连接失败，但是如果是两次握手那么，这次服务端也为客户端创建了连接资源，同样浪费不必要的资源。

个人总结，三次握手是为了防止链路的不稳定而造成服务器资源的浪费。

### 5、System.out.println(0.06+0.05)输出什么
0.11

### 6、数据库知道哪些
基本的增删查改，多表连接，索引，存储过程，事务

### 7、索引讲一下，给两个sql，让我建一个索引；又写了一个问能不能用到这个索引
索引用的是b+树，b+树是一种n叉排序树，只有它的叶子结点存储值，利用好索引，能够提升查询效率，是表优化的重要手段之一。   
**可以扩展到b+树**

创建索引语法：create index [索引名] on [表名] (字段名1,字段名2...)   
**最左匹配原则。**

### 8、事务；特性；隔离级别；脏读，幻读都是什么意思，举个例子；可重复读可以解决幻读吗
事务有四个特性：原子性、一致性、隔离性、持久性；原子性指的是一个事务要么提交，要么不提交。一致性指的是一个事务对一个值进行了加操作，另一个事务对值进行减操作，二者最终结果是一致的。隔离性是指事物之间是独立的，不会相互影响。持久性指一个事务一经提交，那么不可更改。

隔离级别有：读未提交Read UnCommited、读已提交Read Commited、重复读Repeatable Read、串行化Serialize
脏读和幻读是不同隔离级别下会产生的事件。脏读指的是一个事务读取了另一个没有提交的事务的数据，导致读到脏数据；幻读是几次读取的数据偶尔出现偶尔不出现，像是出现了幻觉。

读未提交会产生脏读，Repeatable会产生幻读。

可重复读不能解决幻读。

### 9、画一下kafka的架构；怎么保证幂等性
多个生产者 ---- kafaka cluster --- 多个消费者

保证幂等性好像需要需要引入事务，不熟悉。。。

### 10、你还知道哪些MQ，说下kafka跟他们有什么不同
ActiveMQ，apache旗下的完全支持JMD1.1和J2EE1.4规范的消息总线，java语言开发的，也支持多种语言和协议编写客户端。[ActiveMQ - 百度百科](https://baike.baidu.com/item/ActiveMQ)

### 11、说一下Zookeeper的选主过程


### 12、知道GC吗？说一下CMS，哪些过程是并发的，有什么问题
GC垃圾收集。  
垃圾收集的算法：
* 标记清除、
    - 标记清除算法很简单，找到可以被回收的数据块，标记，之后再一次性清除。缺点是会产生大量碎片，连续收集几次后空间碎片化严重，如果需要一次性分配大空间，可能会得不到满足。
* 标记整理、
    - 标记整理算法顾名思义，分为两步，先标记可以回收的数据块，然后将还存活的地址空间移到一端，再一次性清除被标记的垃圾。缺点是有移动过程，耗时。
* 复制算法、
    - 复制算法的思想是将空间划分成两部分，只用其中的一部分，当需要垃圾回收时一次性将存活的对象复制到另一部分空间，再清空那一部分需要回收的空间。缺点是空间利用率不是很高，需要划分一部分空间出去，利用不到。
* 分代收集
    - 现在大部分垃圾回收器几乎都是用分代收集算法，分代收集算法其实就是对上面三种算法的组合使用。

CMS的意思是：Concurrent Mark Sweep并发标记清除，它是JVM中的一种垃圾回收器。  

CMS垃圾回收的过程主要分为四步：

* 初始标记：标记GCRoot结点
* 并发标记：顺着GCRoot去找到到引用链， **并发**
* 重新标记：再次标记这一过程中新出现的GCRoot
* 并发清除：清除操作 **并发**

### 13、 说一下JMM
JMM意思是Java Memory Model，java内存模型。
虚拟机将内存空间划分为很多部分：程序计数器、虚拟机栈、本地方法栈、堆区、方法区、静态常量池、在java1.4之后还出现了直接内存区。

* 程序计数器：存放的是字节码文件执行的当前行数的地址
* 虚拟机栈：存放了局部变量表，对应变量名和引用的地址的等信息
* 本地方法栈：存放的是由C或C++写的一些本地方法信息，主要是为java方法服务的
* 堆区：堆区是垃圾回收的主要区域，几乎所有的的对象都是在这里发分配内存的。堆区分为两部分，一块是新生代，一块是老年代。新生代中的存放的对象都是生命周期比较短的，老年代存放的是生命周期较长或者大对象直接在这里分配。而年新生代还进行了细分，分为三块：Eden伊甸园、From Survival、To Survival。
* 方法区：存放的是类的Class字节码文件，类的信息等。
* 常量池：常量池区1.7之前是放在堆区的后面已到了方法区中。


