# TCP协议的三次握手和四次握手
### TCP三次握手
![TCP三次握手](https://img-blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

> 第一次握手：客户端发送SYN同步TCP包，置SYN标志位为1，将初始序号X，保存在包头的序号Seq里。  
> 第二次握手：服务端回复确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。  
> 第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z  

**为什么不是两次？**  
1、假如是两次，假如客户端第一次发送的同步包再链路中阻塞了很久，客户端没有等到服务端的回复，以为同步包丢失了，所以再次发送新的同步包，这次服务器接收到了，并在一段时间内与客户端完成了通信，关闭了连接。但是这时第一个在链路中的包又发送过来了，于是服务端以为新的请求，其实这个是失效的请求，但是服务器还是对客户端建立了连接，这样就浪费了资源。

2、还有一种情况，服务器接收到了客户端的连接请求，以为连接已建立，但是如果C并没有受到S的回应呢？此时C任然会认为连接没有建立，S会对已建立的连接保存必要的资源，如果大量的这种情况，服务器S会崩溃。

### TCP四次握手
![TCP四次握手](https://img-blog.csdn.net/20160926193227287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

> 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；  
> 
> 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；  
> 
> 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；  
> 
> 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

**为什么要四次分手？**  
那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。


* **FIN_WAIT_1**: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）
* **FIN_WAIT_2**：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）
* **CLOSE_WAIT**：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）
* **LAST_ACK**: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）
* **TIME_WAIT**: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）
* **CLOSED**: 表示连接中断。

## 系统进程间通信的方式

* 管道（pipe）:管道是一种半双工通信的方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常指的是父子进程。  
* 命名管道（named pipe）：命名管道也是半双工的通信方式，但是它允许无亲缘关系的进程之间进行通信。  
* 信号量（semophoer）:信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同意进程不同线程之间的同步手段。  
* 消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小的限制等缺点。  
* 信号（singal）：信号时一种比较复杂的通信方式，用于通知接受进程某个事件已发生。  
* 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但是多个进程都可以访问。共享内存是最快的的IPC方式，他是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。  
* 套接字（socket）:套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。  

## Servlet生命周期
* 1.加载：Servlet启动的时候会通过类加载器加载我们的Servlet的Class文件。  
* 2.创建：创建过程的时候如果没有在web.xml文件中使用load-on-startup我们在第一次访问我们的Servlet的时候会初始化实例，如果配置了这个并且大于1会在容器启动的时候就创建。
* 3.初始化：init()初始化方法只会被调用一次。在我们实例化被创建之后就会执行初始化。
* 4.处理客户请求：service()在servlet的service方法中会根据不同的http方法来调用。
* 5.卸载：destroy()当我们Servlet需要被卸载的时候就会调用destroy()方法，随后垃圾回收器会回收。

## 设计模式6大原则！！！（重要）

* 单一职责：功能尽可能单一，复杂度降低，提高可读性，提高可维护性，提高扩展性
* 里氏替换：父类能出现的地方可以用子类来替代，而且换成子类也不会出现任何错误或异常，而使用者也无需知道是父类还是子类。
* 依赖倒置：高层模块不依赖底层模块，两者都因该依赖抽象；抽象不依赖细节；细节依赖抽象；
* 接口隔离：建立单一接口，不要建立臃肿庞大的接口。再通俗的说就是接口尽量细化，同时接口中的方法尽量少。
* 迪米特法则：最少知道原则，一个类对自己需要耦合或调用的类知道的最少，而且能完成相同的功能，内部是符合复杂和我没有关系，我就知道你提供的public方法，我只知道调用这些方法，其他的我不关心。（低耦合提供了明确的需求）
* 开闭原则：对内修改关闭，对外扩展开放

## 如何防止Sql注入？
两种办法：前端、后端通过正则表达式过滤请求数据中可能注入的SQL；使用预编译语句PrepareStatement

## DB第一范式，第二范式，第三范式
* 第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。
* 第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。
* 第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF

## 数据库事务的四大特性以及事物的隔离级别

* 原子性（Atomicity）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）

**1.脏读**
脏读就是一个事务读取了该数据并且对该数据做出了修改，另一个事务也读取了该修改后的数据但是前一个事务并没有提交，这是脏数据。
读取到保存在数据库内存中的数据。

**2.不可重复读**  
一个事务：在同一个事务中读取同一数据，得到的内容不同。一个事务读取另外一个事务更新的数据，导致二次的查询的数据不一致。  

**3.虚读（幻影读）** 
幻读是当事务不独立发生的。比如一个事务删除了所有数据，另一个事务又插入了一条，那么第一个事务的用户会发现表中还没有修改的数据行。一个事务读取到另外一个事务提交的数据，导致查询的结果不一致的问题。

现在来看看MySQL数据库为我们提供的四种隔离级别：

① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

③ Read committed (读已提交)：可避免脏读的发生。

④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable Read(可重复读)；而在Oracle数据库中，只支持Serializable(串行化)级别和Read Committed(读已提交)这两种级别，其中默认的为Read Committed级别；

查看MySQL数据库中当前事务的隔离级别：select @@tx_isolation;

## SpringMVC请求流程详解
SpringMVC框架是一个基于请求驱动的Web框架，并且使用了‘前端控制器’模型来进行设计，再根据‘请求映射规则’分发给相应的页面控制器进行处理。  
![SpringMVC请求流程](https://images2015.cnblogs.com/blog/791227/201611/791227-20161125140338768-995727439.png)

具体步骤：

第一步：发起请求到前端控制器(DispatcherServlet)

第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）

第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略

第四步：前端控制器调用处理器适配器去执行Handler

第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler

第六步：Handler执行完成给适配器返回ModelAndView

第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）

第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可

第九步：视图解析器向前端控制器返回View

第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）

第十一步：前端控制器向用户响应结果

### 核心开发步骤
1、  DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC

2、  HandlerMapping 的配置，从而将请求映射到处理器

3、  HandlerAdapter 的配置，从而支持多种类型的处理器

注：处理器映射求和适配器使用纾解的话包含在了注解驱动中，不需要在单独配置

4、  ViewResolver 的配置，从而将逻辑视图名解析为具体视图技术

5、  处理器（页面控制器）的配置，从而进行功能处理 

View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）